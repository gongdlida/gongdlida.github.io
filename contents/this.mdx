# this

함수 호출 시, 호출 방식에 따라 결정되는 실행 컨텍스트의 속성
객체의 프로퍼티로 참조된 함수가 메서드로 호출될 경우, this는 해당 객체를 가리킨다.
이를 통헤 동일한 메서드를 다른 객체에서 활용할 수 있어 재사용성에 좋다.

## 일반함수 호출되는 경우

```js
function foo() {
  return this
}

foo() // window (node global)
```

자바스크립트는 non-strict 환경에서 일반함수로 호출되는 경우,  
this는 globalThis를 가리킨다. (모듈에 따라 달라지는 경우도 있음)

```js
'use strict'
function foo() {
  return this
}

foo() // undefined
```

`'use strict` 엄격모드인 경우 this는 undefined를 바라본다.
this binding 초기화 과정에서 비엄격 모드인 경우에는 this가 undefined나 null일 경우  
globalThis로 치환하는 과정이 존재하며, 엄격모드인 경우에는 치환과정이 없다.
이후에 나오는 모든 예시는 non-strict 기준으로 작성한다.

### 메서드 내에서 호출하는 일반함수

```js
const obj = {
  name: 'obj',
  getName() {
    function foo() {
      console.log(this) // window
    }
    foo()
    return this.name // obj
  }
}

obj.getName()
```

위 코드에서 `foo`함수 호출 시 this는 obj 객체가 아닌 window를 바라본다.  
이유는 메서드로서 호출한 것이 아닌 일반함수로 호출되었기 때문에
기본 바인딩 규칙이 적용된다.

### 콜백

```js
;[1, 2, 3, 4].forEach(function (x) {
  console.log(this, x)
})
```

콜백으로 전달된 함수는 호출 시 일반 함수 형태로 실행되므로,
this는 호출 위치와 무관하게 기본 바인딩 규칙을 따른다.

```js
const obj = {
  name: 'obj',
  foo() {
    console.log(this)
  }
}[(1, 2, 3, 4)].forEach(obj.foo)
```

위 예시에서 고차함수의 인자로 메서드를 넘겨주는 경우 역시 this는 window를 가리킨다.  
콜백함수로 넘긴 함수는 고차함수 입장에서는 foo 함수객체이므로 일반함수이며,  
메서드로 호출된 것이 아닌 일반함수로 호출되었기 떄문이다.

```js
const obj = {
  name: 'obj',
  foo() {
    console.log(this)
  }
}[(1, 2, 3, 4)].forEach(obj.foo, obj) //   {"name": "obj", "foo": f}
```

Array.prototype.forEach, map, filter와 같은 일부 고차함수는 인자값으로 바인딩할 this를 전달 받는다.  
메서드의 this를 유지시켜야 하는 경우, 콜백함수 다음 인자값으로 바인딩할 this를 넣어주면,  
메서드를 소유하고 있는 객체가 바인딩된다.

## 메서드로 호출되는 경우

```js
const obj = {
  name: 'obj',
  getName() {
    return this.name
  }
}

obj.getName() // obj
```

메서드로 호출하는 경우 this는 자신을 소유한 객체이다.  
객체의 프로퍼티로 참조된 함수가 Reference Type을 통해 호출되면,
this는 해당 객체로 바인딩된다.

## call/apply/bind 명시적 this 메서드를 이용해 호출하는 경우

call, apply, bind는 Reference 기반으로 동적으로 계산되는 this를
개발자가 명시적으로 제어하기 위해 제공되는 API이다.

```js
function foo() {
  return this
}

const thisArg = { a: 1 }
foo() // window
foo.call(thisArgs) // {a:1}
foo.apply(thisArgs) // {a:1}
```

call과 apply는 호출 시 인자로 넘긴 this가 바인딩된 함수가 실행된다.

```js
const obj = {
  name: 'obj',
  foo(callback) {
    setTimeout(callback, 100)
  }
}

obj.foo(function () {
  console.log(this.name)
})
```

위 코드에서 foo의 인자로 넘긴 callback은 일반함수로 호출되기 때문에 기본 바인딩 규칙에  
의해 this는 globalThis이며, this.name은 window.name 빈 문자열이 출력된다.

```js
const obj = {
  name: 'obj',
  foo(callback) {
    setTimeout(callback.bind(this), 100)
  }
}

obj.foo(function () {
  console.log(this.name)
})
```

bind 메서드는 메서드 내부의 중첩함수 또는 콜백함수의 this 불일치 문제를 개선할 때 유용하게 사용된다.  
사용 시 apply/call과 달리 함수를 호출하지 않고, 첫번째 인자로 전달한 this 바인딩이 교체된 함수를 반환한다.

## 생성자 함수를 이용해 호출하는 경우

```js
function Human(name, age) {
  this.name = name
  this.age = age
}

const jack = new Human('Jack', 20)
const jhon = new Human('Jhon', 60)

console.log(jack, jhon)
/*
Human {name: Jack, age: 20}
Human {name: Jhon, age: 60}
*/
```

new 키워드로 호출된 함수에서는 새로 생성된 객체가 this로 바인딩된다.

## 화살표 함수의 this

화살표 함수는 this binding 과정이 없어 자체 this를 만들지 않기 때문에  
this를 평가할 때마다 가장 가까운 비-화살표 함수의 this를 그대로 사용한다.
따라서 외부 함수가 실행되기 전에는 참조할 this가 없고,  
외부 함수 실행 후에야 그 this가 결정되어 사용된다.

```js
const obj = {
  name: 'obj',
  foo() {
    const arrow = () => {
      console.log(this.name)
    }

    return arrow()
  }
}
obj.foo() // obj
```

1. foo는 메서드로 호출됨 → foo 실행 컨텍스트 생성 → foo.this = obj

2. foo 실행 중에 arrow 함수 객체가 만들어짐

- 이때 arrow는 own this 없음
- “this는 바깥 this를 쓴다”라는 성질만 가짐

3. arrow() 호출 시점에 this.name 평가

- arrow는 own this가 없으니 바깥(foo)의 this를 사용
- foo의 this는 이미 obj로 정해져 있음
  → "obj" 출력

```js
const obj = {
  name: 'obj',
  bar: () => {
    console.log(this.name)
  }
}
obj.bar() // ''
```

obj.bar()는 메서드 호출 형태이지만,
bar는 화살표 함수이므로 own this binding을 생성하지 않는다.
따라서 메서드 호출 규칙은 적용되지 않고,
this는 정의된 스코프의 상위 this를 그대로 사용한다.

## this 초기화 과정
