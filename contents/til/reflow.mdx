# Critical Path Render (CPR)

브라우저가 웹 페이지를 렌더링 하기위해 필수적으로 진행하는 과정을 CPR라 한다.

```bash
DOM -> CSSOM -> Render Tree build -> layout(reflow) -> paint(repaint) -> composite
```

index.html을 파싱을 하는 DOM 트리 구축부터 합성까지 6단계를 말한다.  
이번 글은 리플로우(레이아웃 계산)에 관한 내용으로 다른 과정을 생략한다.

# 리플로우(레이아웃 계산)

브라우저가 웹 페이지의 뷰포트, 요소들의 크기나 높이와 같은 기하학적 계산을 하는 과정을 레이아웃(layout)이라고 한다.  
전통적으로는 이 계산을 다시 수행하는 것을 리플로우(reflow)라고 부르기도 하는데, 실무/DevTools에서는 둘을 같은 의미로 섞어 쓰는 경우가 많다.  
이 글에서는 용어를 **리플로우**로 통일해서, 최초 계산과 재계산을 모두 포함해 말한다.  
리플로우 발생 시 후속 작업인 리페인트와 합성 작업이 함께 이루어진다.

# 리플로우 발생하는 경우

리플로우 계산은 렌더트리 전반에 파급되어 전파될 수 있어 비용이 커질 수 있다.  
이 영향은 자바스크립트의 실행, 입력처리, 애니메이션 업데이트 같은 ui 이벤트 루프가 지연되며,  
결과적으로 스크롤, 클릭, 타이핑에 대한 반응이 끊기거나 늦어져 사용자 경험에 직접적으로 영향을 준다.  
리플로우에 영향을 줄 수 있는 요소는 다음과 같다.

## 1. 뷰포트/컨테이너 크기 변화(브라우저 창 크기 변경)

외부 요인으로 리플로우 기준이 바뀌어 광범위한 리플로우가 발생

```html
<!-- index.html -->
<style>
  .grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
  }
  @media (max-width: 800px) {
    .grid {
      grid-template-columns: repeat(2, 1fr);
    } /* 뷰포트 변경 시 아이템 폭 재계산 → 리플로우 */
  }
  .item {
    padding: 16px;
    background: #eee;
  }
</style>
<div class="grid">
  <div class="item">A</div>
  <div class="item">B</div>
  <div class="item">C</div>
  <div class="item">D</div>
</div>
```

## 2. DOM 구조 변화(DOM 요소 추가/삭제)

트리 변화로 인접 영역까지 리플로우가 전파

```html
<style>
  /* styles.css */
  .list {
    margin: 16px 0;
  }
  .list li {
    padding: 8px 12px;
    border: 1px solid #ccc;
    margin-bottom: 8px;
  }
</style>

<ul id="list" class="list"></ul>
<button id="add">Add</button>
<button id="remove">Remove</button>

<script>
  const list = document.getElementById('list')
  document.getElementById('add').onclick = () => {
    const li = document.createElement('li')
    li.textContent = `Item ${list.children.length + 1}`
    list.appendChild(li) // 컨테이너 높이 증가 → 주변 요소까지 리플로우 전파
  }
  document.getElementById('remove').onclick = () => {
    // 높이 감소 → 리플로우
    if (list.lastElementChild) list.removeChild(list.lastElementChild)
  }
</script>
```

## 3. 스타일 규칙 변경(요소 클래스 변경)

적용 규칙이 바뀌며 박스의 기하가 달라져 리플로우 발생,  
기하가 그대로인 경우, 리페인트/합성만 밣생

```html
<!-- 토글 활성화에 따른 리플로우 발생 시나리오-->
<style>
  .card {
    width: 200px;
    height: 120px;
    transition: height 200ms;
  }
  .card.expanded {
    height: 240px;
  } /* 높이 변경 → 리플로우(레이아웃 계산) */
</style>

<div id="card" class="card">Card</div>
<button id="toggle">Toggle expand</button>

<script>
  document.getElementById('toggle').onclick = () => {
    document.getElementById('card').classList.toggle('expanded')
  }
</script>
```

## 4. 동기 리플로우(계산된 스타일이 수반되는 JS 메서드 사용)

읽기 → 쓰기 순서가 메인 스레드에서 강제 리플로우를 트리거

```html
<style>
  .box {
    width: 50%;
    height: 100px;
    background: salmon;
  }
</style>

<div id="box" class="box"></div>
<button id="run">Run forced layout</button>

<script>
  document.getElementById('run').onclick = () => {
    const box = document.getElementById('box')
    // 리플로우 결과(레이아웃 값)를 읽는 순간 브라우저는 최신 값을 보장하기 위해 계산을 수행할 수 있음
    const w = box.offsetWidth // 강제 리플로우 가능
    // 곧바로 쓰기: 기하 변경 → 리플로우
    box.style.width = w + 40 + 'px'
  }
</script>
```

# 비동기 리플로우와 동기 리플로우

앞서 살펴본 리플로우 발생 케이스는 모두 동일한 비용을 가지지는 않는다.

1~3번의 경우 브라우저가 변경 사항을 내부적으로 모아 처리할 수 있어
리플로우가 비동기적으로 수행된다.
이 과정에서 브라우저는 스타일 및 리플로우 계산을 지연하거나 배치하여
성능 영향을 최소화한다.

반면 4번은 JavaScript 실행 중 리플로우 값을 즉시 요구하는 방식으로,
브라우저가 렌더링 파이프라인을 강제로 앞당기게 된다.
이로 인해 동기 리플로우(forced synchronous layout)가 발생할 수 있으며,
메인 스레드를 차단해 성능 이슈로 이어질 가능성이 크다.

이 차이를 이해하기 위해,
다음 섹션에서는 브라우저가 리플로우를 어떻게 지연·최적화하는지,
그리고 어떤 조건에서 강제 동기 리플로우가 발생하는지 살펴본다.
