---
slug: 'route'
title: 'React CSR 초기 로딩부터 라우팅까지'
description: 'CSR 환경, 초기 로딩부터 라우팅까지의 브라우저 내부 동작 흐름을 정리합니다.'
tags: ['React', 'CSR', 'React Router']
date: '2024.12.09'
readingTime: '3분'
---

### 1. 데이터 타입 이해

① 원시형(Primitive)

- 메모리에 저장된 원시형 데이터 자체는 불변(immutable)이다.
- 변수에 재할당하면 새로운 메모리 공간에 값이 생기고, 변수는 그 새로운 주소를 가리키게 된다.  
  → 따라서 “변수의 값이 바뀐다”는 것은 실제로는 변수가 가리키는 참조 주소가 바뀌는 것이다.

② 참조형(Reference)

- 변수에는 객체가 저장된 힙 메모리의 주소(참조값)만 저장된다.
- 객체의 프로퍼티는 자유롭게 변경 가능 → 가변(mutable)
- === 비교 시 참조 주소(메모리 위치)를 비교한다.  
  → 내용이 완전히 같아도 서로 다른 객체이면 false

### 2. 객체가 가변형(mutable)인 이유

- 메모리·성능 효율  
  큰 객체를 매번 통째로 복사하면 CPU와 메모리가 엄청낭비된다.
- 대부분의 실무 수정은 일부 프로퍼티만 바꾸면 충분하다.

→ 그래서 JavaScript는 객체를 “참조로 전달”하고,  
필요할 때 프로퍼티만 수정할 수 있게 설계되었다.

### 3. 가변성 때문에 생기는 실무적 문제점

```js
const a = { say: 'hello' }
const b = a // 같은 객체를 가리킴 (shallow copy)

b.say = 'bye'
console.log(a.say) // "bye" → 원본이 의도치 않게 바뀜
```

실제 자주 발생하는 문제들:

- 의도치 않은 사이드 이펙트 (원본 훼손)
- 누가 언제 객체를 수정했는지 추적하기 매우 어렵다
- 코드 예측 가능성 저하 → 디버깅 지옥
- 함수에 객체를 넘길 때 원본까지 바뀌는 위험

### 4. 실전 적용 사례: React의 불변성 패턴

JavaScript의 가변성으로 인해 발생하는 문제를
React는 “불변성(immutability)” 패턴으로 다루고 있다.

React는 상태 변경 여부를 확인할 때
객체 전체를 깊게 비교하는 것이 아니라 **참조(주소)**만 비교한다.

```js
if (prevState !== nextState) {
  // 바뀐 걸로 간주 → 리렌더링
}
```

그런데 JS 객체가 mutable이라는 특성 때문에,
이렇게 상태를 바꾸면 React는 변경을 감지하지 못한다:

❌ 변경 감지 실패

```js
// 원본 객체를 직접 수정 → 참조는 그대로!
state.user.name = 'Jun'
setState(state) // React가 "변한 게 없다"고 판단 → 리렌더링 안 됨
```

✅ 변경 감지 (불변성 유지)

```js
setState((state) => ({
  ...state,
  user: {
    ...state.user,
    name: 'Jun'
  }
}))
```

state !== newState
state.user !== newState.user

두 참조 모두 달라지므로
React는 “명확하게 변경됨”을 감지할 수 있다.

결론
JavaScript 객체는 본질적으로 **가변(mutable)**이기 때문에
의도치 않은 값 변경, 추적 어려움, 예측 불가능성 같은 문제를 만든다.

React는 가변성 문제를 해결하기 위해 참조 비교 기반 렌더링 모델을 사용하며,
“원본을 직접 수정하지 않고, 항상 새로운 객체를 만들어 교체한다.”
라는 불변성(immutable) 패턴을 사실상의 표준으로 채택하고 있다.
